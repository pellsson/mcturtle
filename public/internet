os.loadAPI("utils")

local device_name = ""
local nodes = {}
local node_update = 0.0
local seen_seq = {}
local next_seq = 0

function _get_id()
	return tostring(os.getComputerID())
end

function _register_node(id, name)
	nodes[tostring(id)] = name
end

function force_update_nodes()
	rednet.broadcast("?|" .. device_name, "internet")
	node_update = os.clock() + 15
end

function update_nodes()
	if node_update < os.clock() then
		force_update_nodes()
	end
end

function sync_nodes()
	local done = os.clock() + 2
	force_update_nodes()
	while os.clock() < done do
		receive(1)
	end
end

function connect(name)
	device_name = name
	if nil == device_name then
		device_name = _get_id()
	end

	local sides = { "top" , "bottom" , "front" , "left" , "right" , "back" }
	local modems = {}

	for i=1, #sides do
		if peripheral.isPresent(sides[i]) and peripheral.getType(sides[i]) == "modem" then
			rednet.open(sides[i])
			rednet.host("internet", device_name)
			sync_nodes()
			return true
		end
	end
	print("No modem found!")
	return false
end

function disconnect()
	rednet.unhost("internet", device_name)
end

function local_nodes()
	local ret = {}
	for k, v in pairs(nodes) do
		table.insert(ret, k)
	end
	return ret
end

function named_local_nodes()
	return nodes
end

function find_local(name)
	for k, v in pairs(nodes) do
		if v == name then
			return k
		end
	end
	return nil
end

function _inner_send(to, passed, seq, message)
	local knows_target = find_local(to)
	local cid = _get_id()

	if knows_target then
		rednet.send(tonumber(knows_target), to .. ',' .. passed[1] .. ':' .. seq .. '|' .. message, "internet")
		return true
	end

	local all = local_nodes()
	local raw = tostring(to) .. ','
	local send_to = {}

	for i=1, #all do
		local in_passed = false
		for j=1, #passed do
			if all[i] == passed[j] then
				in_passed = true
				break
			end
		end
		if not in_passed then
			table.insert(passed, all[i])
			if all[i] ~= cid then
				table.insert(send_to, all[i])
			end
		end
	end

	if 0 == #send_to then
		return
	end

	for i=1, #passed do
		raw = raw .. tostring(passed[i]) .. ','
	end
	raw = raw .. ':' .. seq .. '|' .. message
	for i=1, #send_to do
		rednet.send(tonumber(send_to[i]), raw, "internet")
	end
end

function has_seen_before(from, seq)
	if seq == seen_seq[from] then
		return true
	end
	seen_seq[from] = seq
	return false
end

function inner_receive(timeout)
	local cid = _get_id()
	update_nodes()

	local sender, message, protocol = rednet.receive("internet", timeout)
	if nil == sender then
		return nil
	end

	local header, payload = message:match("([^|]+)|(.*)")

	if '?' == header then
		_register_node(sender, payload)
		rednet.send(sender, "!|" .. cid, "internet")
		return nil
	elseif '!' == header then
		_register_node(sender, payload)
		return nil
	end

	local header, seq = header:match("([^:]+):(.*)")

	passed = utils.tokenize(header, ',')

	local to = passed[1]
	local from = passed[2]

	if has_seen_before(from, seq) then
		return nil
	end

	if to == cid then
		return from, payload
	end

	table.remove(passed, 1)
	_inner_send(to, passed, seq, payload)

	if '*' ~= to then
		return nil
	end

	return from, payload
end

function internal_packet(from, payload)
	if 'ping' == payload then
		send(from, 'pong' .. ':' .. device_name .. ':' .. tostring(utils.current_ticks()))
		return true
	end
	return false
end

function receive(timeout)
	if timeout then
		timeout = tonumber(timeout)
	end

	local time_start = os.clock()
	local timeout_at = utils.ternary(timeout, os.clock(), nil)

	while true do
		local from, payload = inner_receive(timeout)
		if nil == from then
			if timeout_at and timeout_at < os.clock() then
				return nil
			end
		else
			if not internal_packet(from, payload) then
				return from, payload
			end
		end

		if timeout then
			timeout = timeout - (os.clock() - time_start)
			if timeout < 0 then
				timeout = 0
			end
		end
	end
end

function send(to, message)
	update_nodes()
	_inner_send(tostring(to), { _get_id() }, tostring(next_seq), message)
	next_seq = next_seq + 1
end

function parse_pong(data)
	local name, ticks = data:match("pong:(.+):([0-9]+)")
	if name then
		return { name = name, ticks = tonumber(ticks) }
	end
	return nil
end

function send_ping(to, timeout)
	local replies = {}
	if nil == timeout then
		timeout = 5
	else
		timeout = tonumber(timeout)
	end

	local start = os.clock()
	local sent_at = utils.current_ticks()
	internet.send(to, "ping")

	while true do
		local from, payload = receive(timeout)
		if from then
			local ping_data = parse_pong(payload)

			if ping_data then
				ping_data.ticks = (ping_data.ticks - sent_at)
				table.insert(replies, ping_data)

				if from and '*' ~= from then
					return replies
				end
			end
		end
		timeout = timeout - (os.clock() - start)
		if timeout < 0 then
			break
		end
	end

	return replies
end

--internet_register(get_device_name())





