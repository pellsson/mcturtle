os.loadAPI("utils")

SOUTH	= 0
WEST	= 1
NORTH	= 2
EAST	= 3
local wt	= {}	-- world table
local at	= wt	-- active table
local _fuel_items = { "minecraft:coal", "IC2:item.itemScrap", "Railcraft:fuel.coke", "Forestry:peat", "minecraft:lava_bucket" }

function _w_fatal(s)
	while true do
		print("Fatal! " .. s)
		os.sleep(10)
	end
end

function _w_do_actions(actions, sufix)
	if not actions then
		return
	end
	local a = utils.tokenize(actions, ',')
	for i=1, #a do
		turtle[a[i] .. sufix]()
	end
end

function _w_forward(actions)
	_w_do_actions(actions, '')
	return turtle.forward()
end

function _w_up(actions)
	_w_do_actions(actions, 'Up')
	return turtle.up()
end

function _w_down(actions)
	_w_do_actions(actions, 'Down')
	return turtle.down()
end

function _w_turn_right()
	return turtle.turnRight()
end

function _w_turn_left()
	return turtle.turnLeft()
end

function _forward(actions)

	if not at.forward(actions) then
		return false
	end

	if SOUTH == at.dir then
		at.z = at.z + 1
	elseif NORTH == at.dir then
		at.z = at.z - 1
	elseif EAST == at.dir then
		at.x = at.x + 1
	elseif WEST == at.dir then
		at.x = at.x - 1
	end
	at.save_pos()
	return true
end

function _turn_left()
	if not at.turn_left() then
		return false
	end
	if SOUTH == at.dir then
		at.dir = EAST
	elseif EAST == at.dir then
		at.dir = NORTH
	elseif NORTH == at.dir then
		at.dir = WEST
	elseif WEST == at.dir then
		at.dir = SOUTH
	end
	at.save_pos()
	return true
end

function _turn_right()
	if not at.turn_right() then
		return false
	end
	if SOUTH == at.dir then
		at.dir = WEST
	elseif WEST == at.dir then
		at.dir = NORTH
	elseif NORTH == at.dir then
		at.dir = EAST
	elseif EAST == at.dir then
		at.dir = SOUTH
	end
	at.save_pos()
	return true
end

function _up(actions)
	if not at.up(actions) then
		return false
	end
	at.y = at.y + 1
	at.save_pos()
	return true
end

function _down(actions)
	if not at.down(actions) then
		return false
	end
	at.y = at.y - 1
	at.save_pos()
	return true
end

function _w_save_pos()
	local fp = fs.open(".position", "w")
	if nil == fp then
		return false
	end
	fp.writeLine(tostring(wt.x))
	fp.writeLine(tostring(wt.y))
	fp.writeLine(tostring(wt.z))
	fp.writeLine(tostring(wt.dir))
	fp.close()
	return true
end

function _load_pos_file(fp)
	wt.x = tonumber(fp.readLine())
	wt.y = tonumber(fp.readLine())
	wt.z = tonumber(fp.readLine())
	wt.dir = tonumber(fp.readLine())
end

function _load_pos(filename)
	local fp = fs.open(filename, "r")
	if not fp then
		return false
	end
	_load_pos_file(fp)
	fp.close()
	return true
end

function _out_of_fuel()
	return (turtle.getFuelLevel() ~= "unlimited") and (turtle.getFuelLevel() < 1)
end

function _refuel()
	local success = false
	if not _out_of_fuel() then
		return true
	end
	local old = turtle.getSelectedSlot()
	for i=1, 16 do
		turtle.select(i)
		if turtle.refuel(1) and turtle.getFuelLevel() > 0 then
			success = true
			break
		end
	end
	turtle.select(old)
	return success
end

function _force_refuel()
	while not _refuel() do
		print("Help! I need gas")
		os.sleep(3)
	end
end

MOVE_OK			= 1
MOVE_NO_FUEL	= 2
MOVE_BLOCKED	= 3
MOVE_USER_ABORT	= 4

function _try_move(movement, actions)
	if at.on_pre_move and not at.on_pre_move() then
		return MOVE_USER_ABORT
	end

	if not _refuel() then
		if at.on_no_fuel and not at.on_no_fuel() then
			return MOVE_USER_ABORT
		end
		return MOVE_NO_FUEL
	end

	if not movement(actions) then
		if at.on_blocked and not at.on_blocked() then
			return MOVE_USER_ABORT
		end
		return MOVE_BLOCKED
	end
	return MOVE_OK
end

function _move(movement, actions)
	local rc = nil
	while MOVE_OK ~= rc do
		rc = _try_move(movement, actions)
		if MOVE_USER_ABORT == rc then
			return false
		elseif MOVE_NO_FUEL == rc then
			_force_refuel()
		elseif MOVE_BLOCKED == rc then
			print("Help! I am blocked")
			os.sleep(2)
		end
	end
	return true
end

function _goto_over(dir, actions)
	local rc = _try_move(dir, actions)
	if MOVE_USER_ABORT == rc then
		return true, false
	end
	return false, (MOVE_OK == rc)
end

function _goto_forward(key, to)
	local y = 0
	local blocked = false
	while at[key] ~= to do
		if blocked then
			turtle.dig()
		end

		local rc = _try_move(_forward, actions)

		if MOVE_USER_ABORT == rc then
			return false
		elseif MOVE_NO_FUEL == rc then
			_force_refuel()
		elseif MOVE_BLOCKED == rc then
			if 0 == y then
				local aborted, moved = _goto_over(_up, actions)
				if aborted then
					return false
				elseif moved then
					y = 1
				else
					aborted, moved = _goto_over(_down, actions)
					if aborted then
						return false
					elseif moved then
						y = -1
					else
						blocked = true
					end
				end
				if 0 ~= y then
					blocked = false
				end
			else
				local func = utils.ternary(y > 0, _up, _down)
				local aborted, moved = _goto_over(func, actions)
				if aborted then
					return false
				end
				if not moved then
					print("Halp! I am blocked (goto)")
					os.sleep(2)
				end
				blocked = not moved
			end
		elseif MOVE_OK then
			y = 0
			blocked = false
		else
			at.fatal("Wat?")
		end
	end

	return true
end

function _goto_x(dx, actions)
	if at.x == dx then
		return true
	end
	if at.x < dx then
		if not face(EAST) then
			return false
		end
	else
		if not face(WEST) then
			return false
		end
	end
	return _goto_forward('x', dx)
end

function _goto_z(dz, actions)
	if at.z == dz then
		return true
	end
	if at.z < dz then
		if not face(SOUTH) then
			return false
		end
	else
		if not face(NORTH) then
			return false
		end
	end
	return _goto_forward('z', dz)
end

function _goto_y(dy, actions)
	local func = utils.ternary(at.y < dy, _up, _down)
	local dig = utils.ternary(at.y < dy, "digUp", "digDown")
	while at.y ~= dy do
		turtle[dig]()
		local rc = _try_move(func, actions)
		if MOVE_USER_ABORT == rc then
			return false
		elseif MOVE_NO_FUEL == rc then
			_force_refuel()
		elseif MOVE_BLOCKED == rc then
			print("Halp, I blocked going up or down")
			os.sleep(2)
		end
	end
	return true
end

function goto(x, y, z, dir, actions)
	return _goto_x(x, actions) and _goto_z(z, actions) and _goto_y(y, actions) and face(dir)
end

function turn_around(actions)
	return _move(_turn_right, nil) and _move(_turn_right, nil)
end

function turn_right()
	return _move(_turn_right, nil)
end

function turn_left()
	return _move(_turn_left, nil)
end

function forward(actions)
	return _move(_forward, actions)
end

function up(actions)
	return _move(_up, actions)
end

function down(actions)
	return _move(_down, actions)
end

function face(d)
	if d == at.dir then
		return true
	end
	if NORTH == at.dir then
		if SOUTH == d then
			return turn_around()
		elseif WEST == d then
			return turn_left()
		elseif EAST == d then
			return turn_right()
		end
	elseif SOUTH == at.dir then
		if NORTH == d then
			return turn_around()
		elseif WEST == d then
			return turn_right()
		elseif EAST == d then
			return turn_left()
		end
	elseif WEST == at.dir then
		if EAST == d then
			return turn_around()
		elseif NORTH == d then
			return turn_right()
		elseif SOUTH == d then
			return turn_left()
		end
	elseif EAST == at.dir then
		if WEST == d then
			return turn_around()
		elseif NORTH == d then
			return turn_left()
		elseif SOUTH == d then
			return turn_right()
		end
	end
	at.on_fatal("Impossible condition in face()")
end

function get_x()
	return at.x
end

function get_y()
	return at.y
end

function get_z()
	return at.z
end

function get_dir()
	return at.dir
end

function get_pos()
	return at.x, at.y, at.z, at.dir
end

function get_opposite_dir()
	if EAST == at.dir then
		return WEST
	elseif WEST == at.dir then
		return EAST
	elseif NORTH == at.dir then
		return SOUTH
	elseif SOUTH == at.dir then
		return NORTH
	end
	at.on_fatal("Wat? where are we facing lol...")
end

function dump_pos()
	print("Pos: " .. tostring(at.x) .. "," .. tostring(at.y) .. "," .. tostring(at.z) .. ":" .. tostring(at.dir))
end

function initialize()
	if false == _load_pos("disk/.position") then
		if false == _load_pos(".position") then
			return false
		end
	end

	at = wt

	dump_pos()

	wt["forward"]		= _w_forward
	wt["turn_right"]	= _w_turn_right
	wt["turn_left"]		= _w_turn_left
	wt["up"]			= _w_up
	wt["down"]			= _w_down
	wt["on_no_fuel"]	= nil
	wt["on_blocked"]	= nil
	wt["on_pre_move"]	= nil
	wt["on_fatal"]		= _w_fatal
	wt["save_pos"]		= _w_save_pos

	wt.save_pos()
	return true
end



